Yes, I see what you're aiming for:

Avoid double print dialogs (which might be caused by fallback triggers overlapping with load events).

Open separate tabs for each file (to parallelize or batch print jobs efficiently).

Control timing better so browser doesn't block tabs due to popups or rate limits.

Let me help you fix both issues in a clean way:

✅ Fixes & Improvements:
Prevent duplicate print triggers (using once event listener and clearing fallbacks).

Open multiple tabs — one per file — and print in parallel, optionally with slight delay.

Throttle the tab openings with a minimum delay to avoid browser blocking them as popups.

✅ Updated Solution:
ts
Copy
Edit
export const printFile = async (file: any): Promise<void> => {
  const fileUrl = `/uploads/${file.filename || file}`;
  const filename = file.originalName || file.filename || file;
  const fileExtension = filename.split('.').pop()?.toLowerCase();

  return new Promise((resolve) => {
    const printWindow = window.open('', '_blank');

    if (!printWindow) {
      console.error('Popup blocked');
      resolve();
      return;
    }

    const isImage = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'].includes(fileExtension || '');
    const isPDF = fileExtension === 'pdf';

    const content = isImage
      ? `<img src="${fileUrl}" id="printContent" />`
      : isPDF
        ? `<embed src="${fileUrl}" type="application/pdf" id="printContent" />`
        : `<iframe src="${fileUrl}" id="printContent"></iframe>`;

    printWindow.document.write(`
      <html>
        <head>
          <title>Print - ${filename}</title>
          <style>
            body { margin: 0; padding: 0; overflow: hidden; }
            img, embed, iframe { width: 100vw; height: 100vh; border: none; object-fit: contain; }
            @media print {
              html, body, img, embed, iframe {
                width: 100%;
                height: 100%;
                page-break-inside: avoid;
                break-inside: avoid;
              }
            }
            @page { margin: 0; size: auto; }
          </style>
        </head>
        <body>${content}</body>
      </html>
    `);
    printWindow.document.close();

    let printed = false;

    const tryPrint = () => {
      if (printed) return;
      printed = true;
      try {
        printWindow.focus();
        printWindow.print();
      } catch (e) {
        console.error('Print failed:', e);
      }
      resolve();
    };

    const element = printWindow.document.getElementById('printContent');
    if (element) {
      element.onload = () => setTimeout(tryPrint, 200);  // short delay after load
      element.onerror = tryPrint;

      // fallback if onload never fires
      setTimeout(tryPrint, 4000);
    } else {
      setTimeout(tryPrint, 3000); // fallback for unknown types
    }
  });
};
✅ Parallel Print with Controlled Tab Gaps
ts
Copy
Edit
export const printAllFiles = async (
  files: any[],
  onProgress?: (current: number, total: number) => void,
  delayBetweenTabs = 600 // milliseconds
): Promise<void> => {
  const parsedFiles = typeof files === 'string' ? JSON.parse(files) : files;

  for (let i = 0; i < parsedFiles.length; i++) {
    // Open each print task slightly delayed to avoid browser blocking
    setTimeout(() => {
      printFile(parsedFiles[i]).then(() => {
        if (onProgress) onProgress(i + 1, parsedFiles.length);
      });
    }, i * delayBetweenTabs);
  }
};
⚠️ Browser Notes:
Browsers may block multiple tabs if not triggered by real user interaction. Keep printAllFiles inside a click-triggered function.

Best if called inside a user-initiated event, like a button click.

✅ Example Use:
ts
Copy
Edit
<button onClick={() => printAllFiles(filesArray)}>Print All</button>
